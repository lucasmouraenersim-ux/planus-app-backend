
 <!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8">
  <title>Tempo Severo no Hemisf√©rio Sul</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>

  <!-- ArcGIS API CSS -->
  <link rel="stylesheet" href="https://js.arcgis.com/3.35/esri/css/esri.css">
  <link rel="stylesheet" href="https://js.arcgis.com/3.35/dijit/themes/claro/claro.css">

  <style>
    html, body, #outerPane {
      width:100%; height:100%; margin:0; padding:0;
    }
    #outerPane { position:relative; }
    #sidebar {
      position:absolute; top:0; left:0; bottom:0;
      width:300px; background:#fff; overflow:auto;
      border-right:1px solid #ccc; padding:10px;
      box-sizing:border-box;
    }
    #mapDiv {
      position:absolute; top:60px; right:0; bottom:0; left:300px;
    }

    .section { margin-bottom:20px; }
    .section h3 { margin:0 0 8px 0; font-family:Segoe UI, sans-serif; color:#1f4059; }
    #layersDiv input { margin-right:4px; }
    .esriPrint { margin-top:10px; }

    #topbar {
      position: fixed; top: 0; left: 0; right: 0;
      height: 60px; background: #003366; color: white;
      display: flex; align-items: center; justify-content: space-between;
      padding: 0 15px; z-index: 9999;
    }
    #topbar .left { display: flex; align-items: center; gap: 10px; }
    #topbar .left img { height: 30px; }
    #topbar .left h1 { font-size: 18px; margin: 0; }
    #topbar input[type="text"] {
      padding: 6px; font-size: 14px; width: 250px;
    }
    #topbar .right { display: flex; align-items: center; gap: 8px; }
    .top-btn {
      background: none; border: none; color: white;
      font-size: 20px; cursor: pointer;
    }
    .top-btn:hover {
      background-color: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
    }
    .date-controls {
      display: flex; align-items: center; gap: 4px;
    }
    .date-controls input[type="date"] {
      padding: 3px 6px; font-size: 13px;
    }
    .date-controls .date-btn {
      background: #0066cc; color: white; border: none;
      padding: 4px 8px; font-size: 13px; border-radius: 3px;
      cursor: pointer;
    }

    #customTools {
      position: fixed;
      top: 150px;
      left: 320px;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    #customTools button {
      width: 32px;
      height: 32px;
      background: white;
      border: none;
      cursor: pointer;
      font-size: 18px;
      line-height: 1;
      box-shadow: 0 0 3px rgba(0,0,0,0.2);
    }
    #customTools button:hover {
      background: #eee;
    }

    /* Modal Forecast */
    #forecastModal {
      display:none;
      position:fixed;
      top:50%; left:50%;
      transform:translate(-50%,-50%);
      width:300px; background:#fff;
      padding:20px;
      border:1px solid #ccc;
      border-radius:8px;
      box-shadow:0 4px 10px rgba(0,0,0,0.2);
      z-index:99999;
      font-family:sans-serif;
    }
    #forecastModal h3 { margin-top:0; }
    #forecastModal select {
      width: 100%;
      padding: 6px;
      margin-top: 8px;
    }
    #forecastModal button {
      margin-top: 12px;
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    #forecastModal .cancel { background: #ccc; }
    #forecastModal .save { background: #0066cc; color: white; margin-left: 10px; }

    /* Modal de Coordenadas */
    #coordModal {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      z-index: 10000;
      width: 300px;
    }
    #coordModal input {
      width: 100%;
      padding: 8px;
      margin: 5px 0;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    #coordModal button {
      margin-top: 10px;
      padding: 8px 15px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    #coordModal .save {
      background: #0066cc;
      color: white;
    }
    #coordModal .cancel {
      background: #ccc;
      margin-right: 10px;
    }
    
    /* Controles de Overlay */
    #overlayControls {
      position: fixed;
      top: 120px;
      right: 20px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      z-index: 9999;
      font-size: 13px;
      font-family: sans-serif;
    }
    #overlayControls input[type="range"] {
      width: 100px;
      margin-top: 5px;
    }

    .radar-controls {
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 5px;
      margin-top: 10px;
    }
    .radar-controls h4 {
      margin: 0 0 10px 0;
      font-size: 14px;
    }
    .radar-controls h5 {
      margin: 5px 0;
      font-size: 13px;
    }
    .radar-group {
      margin-bottom: 10px;
    }
    .radar-group label {
      display: inline-block;
      margin-right: 10px;
      font-size: 12px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Estilo para tela cheia */
    :fullscreen {
      width: 100vw !important;
      height: 100vh !important;
      background: white;
    }

    /* Suporte para diferentes navegadores */
    :-webkit-full-screen {
      width: 100vw !important;
      height: 100vh !important;
      background: white;
    }

    :-moz-full-screen {
      width: 100vw !important;
      height: 100vh !important;
      background: white;
    }

    :-ms-fullscreen {
      width: 100vw !important;
      height: 100vh !important;
      background: white;
    }
  </style>

  <!-- ArcGIS API -->
  <script src="https://js.arcgis.com/3.35/"></script>
</head>

<body class="claro">
  <!-- Loading Overlay -->
  <div id="loadingOverlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 51, 102, 0.95); display: flex; justify-content: center; align-items: center; z-index: 99999;">
      <div style="text-align: center;">
          <div style="border: 4px solid #f3f3f3; border-top: 4px solid #00cfff; border-radius: 50%; width: 60px; height: 60px; animation: spin 1s linear infinite; margin: 0 auto 20px;"></div>
          <div style="font-family: Arial, sans-serif; font-size: 24px; color: white;">Carregando...</div>
      </div>
  </div>

  <script>
    // Fun√ß√£o para for√ßar tela cheia
    function forceFullscreen() {
        const elem = document.documentElement;
        try {
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.webkitRequestFullscreen) {
                elem.webkitRequestFullscreen();
            } else if (elem.msRequestFullscreen) {
                elem.msRequestFullscreen();
            } else if (elem.mozRequestFullScreen) {
                elem.mozRequestFullScreen();
            }
        } catch (err) {
            console.warn("‚ö†Ô∏è N√£o foi poss√≠vel ativar tela cheia:", err);
        }
    }

    // Controle do loading e ativa√ß√£o da tela cheia
    window.addEventListener('load', function() {
        setTimeout(function() {
            var loadingOverlay = document.getElementById('loadingOverlay');
            loadingOverlay.style.opacity = '0';
            loadingOverlay.style.transition = 'opacity 1s';
            setTimeout(function() {
                loadingOverlay.style.display = 'none';
                forceFullscreen();
            }, 1000);
        }, 8000); // Aumentei para 8 segundos
    });
  </script>

  <!-- Input de arquivo (movido para o in√≠cio do body) -->
  <input type="file" id="geoImageInput" accept=".jpg,.jpeg,.png,.tif,.tiff" style="display:none">

  <!-- Topbar NOAA -->
  <div id="topbar">
    <div class="left">
      <h1>Tempo Severo no Hemisf√©rio Sul</h1>
      <input type="text" id="searchInput" placeholder="Find address or place..." />
    </div>

    <!-- Controles do tipo de risco e probabilidade -->
    <div id="riskControls" style="
      position: fixed;
      top: 70px;
      right: 20px;
      z-index: 9999;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 10px;
    ">
      <label>
        Tipo:
        <select id="hazardSel">
          <option value="hail">Granizo</option>
          <option value="wind">Vento</option>
          <option value="tornado">Tornado</option>
        </select>
      </label>

      <label>
        Prob(%):
        <select id="probSel"></select>
      </label>

      <label style="display: flex; align-items: center; gap: 4px;">
        <input type="checkbox" id="chkForecastView">
        <span>Ver previs√£o feita</span>
      </label>
    </div>

    <div id="legendPrevots" style="
      display: none;
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(255,255,255,0.95);
      padding: 10px 14px;
      font-size: 13px;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      font-family: sans-serif;
      z-index: 9999;
    ">
      <b>N√≠veis PREVOTS</b>
      <div>
        <div><span style="display:inline-block;width:14px;height:14px;background:#00FF00;margin-right:6px;border-radius:2px;"></span>PREV 1</div>
        <div><span style="display:inline-block;width:14px;height:14px;background:#FFFF00;margin-right:6px;border-radius:2px;"></span>PREV 2</div>
        <div><span style="display:inline-block;width:14px;height:14px;background:#FFA500;margin-right:6px;border-radius:2px;"></span>PREV 3</div>
        <div><span style="display:inline-block;width:14px;height:14px;background:#FF0000;margin-right:6px;border-radius:2px;"></span>PREV 4</div>
      </div>
    </div>

    <div class="right">
      <button class="top-btn" title="Filtro">üîç</button>
      <button class="top-btn" title="Adicionar Dados">‚ûï</button>
      <button class="top-btn" title="Camadas">üìö</button>
      <button class="top-btn" title="Legenda">üìã</button>
      <button class="top-btn" title="Resultados">üìë</button>
      <button class="top-btn" title="Informa√ß√µes">‚ÑπÔ∏è</button>
      <button class="top-btn" onclick="resetMap()" title="Reset View">üîÑ</button>
      <button class="top-btn" onclick="triggerImageUpload()" title="Carregar Imagem">üñºÔ∏è</button>
      <button class="date-btn" id="btnSubmitForecast">Enviar previs√£o</button>
      <div class="date-controls">
        <label>De: <input type="date" id="startDate" /></label>
        <label>At√©: <input type="date" id="endDate" /></label>
        <button class="date-btn" id="submitDate">Buscar</button>
        <button class="date-btn">Resetar</button>
      </div>
    </div>
  </div>

  <!-- Bot√µes flutuantes -->
  <div id="customTools">
    <button onclick="toggleFullscreen()" title="Tela Cheia">‚õ∂</button>
    <button onclick="activatePolygonDraw()" title="Desenhar Pol√≠gono">‚¨¢</button>
  </div>

  <!-- Painel lateral NOAA -->
  <div id="outerPane">
    <div id="sidebar">
      <div class="section">
        <h3>Filtro Temporal</h3>
        <div id="timeSliderDiv"></div>
      </div>
      <div class="section">
        <h3>Camadas</h3>
        <div id="layersDiv">
          <label><input type="checkbox" id="chkPoints" checked> Pontos</label><br>
          <label><input type="checkbox" id="chkLines" checked> Linhas</label><br>
          <label><input type="checkbox" id="chkPolygons" checked> Pol√≠gonos</label>
        </div>
      </div>
      <div class="section">
        <h3>Legenda</h3>
        <div id="legendDiv"></div>
      </div>
      <div class="section">
        <h3>Mapas Base</h3>
        <div id="basemapGalleryDiv"></div>
      </div>
      <div class="section">
        <h3>Vis√£o Geral</h3>
        <div id="overviewMapDiv" style="height:150px;"></div>
      </div>
      <div class="section">
        <div id="homeButtonDiv"></div>
        <div id="printDiv"></div>
      </div>
    </div>
    <div id="mapDiv"></div>
  </div>
  <div id="legendRisk" style="
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: rgba(255,255,255,0.95);
    padding: 10px 14px;
    font-size: 13px;
    border-radius: 6px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    font-family: sans-serif;
    z-index: 9999;
  ">
    <b>Legenda por risco</b>
    <div id="legendItems"></div>
  </div>

  <!-- Painel lateral Adicionar Dados -->
  <div id="addDataPanel" class="panel">
    <div class="panel-header">
      <strong>Adicionar Dados</strong>
      <button class="panel-close" onclick="closeAddDataPanel()">‚úñ</button>
    </div>
    <div class="panel-content">
      <div class="search-bar">
        <input type="text" id="searchArcGIS" placeholder="Buscar camadas p√∫blicas..." />
        <button onclick="searchArcGIS()">üîç</button>
      </div>
      <div id="searchResults"></div>
    </div>
  </div>
 
  <!-- Legenda de √≠cones dos relatos -->
  <div id="legendReports" style="
    position: fixed;
    bottom: 95px;
    left: 320px;
    background: rgba(255,255,255,0.95);
    padding: 10px 14px;
    font-size: 13px;
    border-radius: 6px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    font-family: sans-serif;
    z-index: 9999;
  ">
    <b>Relatos</b><br>
    <div><img src="https://static.wixstatic.com/media/c003a9_38c6ec164e3742dab2237816e4ff8c95~mv2.png" width="16"> Vento 80‚Äì100km/h</div>
    <div><img src="https://static.wixstatic.com/media/c003a9_3fc6c303cb364c5db3595e4203c1888e~mv2.png" width="16"> Vento >100km/h</div>
    <div><img src="https://static.wixstatic.com/media/c003a9_70be04c630a64abca49711a423da779b~mv2.png" width="16"> Granizo < 4cm</div>
    <div><img src="https://static.wixstatic.com/media/c003a9_946684b74c234c2287a153a6b6c077fe~mv2.png" width="16"> Granizo > 4cm</div>
    <div><img src="https://static.wixstatic.com/media/c003a9_9f22188e065e4424a1f8ee3a3afeffde~mv2.png" width="16"> Tornado < EF2</div>
    <div><img src="https://static.wixstatic.com/media/c003a9_3a647b1160024b55bb3ecc148df1309f~mv2.png" width="16"> Tornado ‚â• EF2</div>
  </div>

  <div id="hudOverlay" style="
    position: fixed;
    bottom: 8px;
    left: 320px;
    background: rgba(0,0,0,0.7);
    color: white;
    font-family: monospace;
    font-size: 12px;
    padding: 4px 8px;
    border-radius: 4px;
    z-index: 9999;
    pointer-events: none;
  ">
    üìç --,-- ¬∞
  </div>

  <!-- Painel de Estat√≠sticas -->
  <div id="statsPanel" style="
    position: fixed;
    bottom: 180px;
    right: 20px;
    background: rgba(255,255,255,0.95);
    padding: 10px 14px;
    font-size: 13px;
    border-radius: 6px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    font-family: sans-serif;
    z-index: 9999;
  ">
    <div id="statsContent">Carregando...</div>
  </div>

  <div id="overlayControls" style="
    position: fixed;
    top: 120px;
    right: 20px;
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 8px 12px;
    border-radius: 6px;
    z-index: 9999;
    font-size: 13px;
    font-family: sans-serif;
  ">
    <b>Sobreposi√ß√µes</b><br>
    <label><input type="checkbox" id="toggleRainviewer"> Radar (RainViewer)</label><br>
    <label><input type="checkbox" id="toggleMunicipios"> Munic√≠pios</label><br>
    <div id="imageControls">
      <label><input type="checkbox" id="toggleOverlay"> Mostrar Imagem</label><br>
      <div id="opacityControl" style="margin-left: 20px; display: none;">
        Opacidade: <span id="opacityValue">100%</span><br>
        <input type="range" id="opacitySlider" min="0" max="100" value="100" style="width: 100%;">
      </div>
    </div>
  </div>

  <!-- Modal para salvar previs√£o -->
  <div id="forecastModal">
    <h3>Salvar Previs√£o</h3>
    <label>Dia:
      <select id="dayType">
        <option value="hoje">Hoje</option>
        <option value="amanh√£">Amanh√£</option>
      </select>
    </label>
    <br><br>
    <button class="cancel" onclick="cancelForecast()">Cancelar</button>
    <button class="save" onclick="confirmForecast()">Salvar</button>
  </div>

  <!-- Modal de escolha -->
  <div id="choiceDlg" style="
    display: none;
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: #262626;
    color: white;
    border: 1px solid #999;
    border-radius: 6px;
    padding: 16px 20px;
    font-family: sans-serif;
    font-size: 14px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.6);
    z-index: 10000;
  ">
    <div style="margin-bottom: 10px">O que deseja visualizar?</div>
    <button onclick="setForecastView('all')">Todos os riscos</button>
    <button onclick="setForecastView('overall')">Mapa geral</button>
  </div>

  <!-- Modal de Coordenadas -->
  <div id="coordModal" style="
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    z-index: 10000;
    width: 300px;
  ">
    <h3>Coordenadas da Imagem</h3>
    <div style="margin-bottom: 15px;">
      <button id="btnAutoLoad" class="auto-load" style="width: 100%; padding: 10px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; margin-bottom: 10px;">
        Carregar Automaticamente
      </button>
      <div style="text-align: center; color: #666; margin: 5px 0;">- ou -</div>
      <div style="text-align: center; color: #666; font-size: 12px;">Ajuste as coordenadas manualmente:</div>
    </div>
    <label>Longitude M√≠nima (Oeste):<br>
      <input type="number" id="lonMin" step="0.000001" value="-60.503571">
    </label><br>
    <label>Longitude M√°xima (Leste):<br>
      <input type="number" id="lonMax" step="0.000001" value="-38.495731">
    </label><br>
    <label>Latitude M√≠nima (Sul):<br>
      <input type="number" id="latMin" step="0.000001" value="-33.002845">
    </label><br>
    <label>Latitude M√°xima (Norte):<br>
      <input type="number" id="latMax" step="0.000001" value="-16.497153">
    </label><br>
    <button id="btnCancelLoad" class="cancel">Cancelar</button>
    <button id="btnLoadCoords" class="save">Carregar Manual</button>
  </div>

  <script>
  let forecastGraphics = [];
  let forecastMode = "all"; // "all" ou "overall"
  let brazilBoundary = null;
  let brazilBoundaryReady = false;

  let currentUser = null;

  // üîí Escuta login enviado pelo Wix
  window.addEventListener("message", (e) => {
    const msg = e.data;

    try {
      const parsed = typeof msg === "string" ? JSON.parse(msg) : msg;

      if (parsed?.loggedIn) {
        currentUser = {
          email: parsed.email,
          nick: parsed.nick || parsed.email?.split("@")[0],
          memberId: parsed.memberId || null
        };
        console.log("‚úÖ Usu√°rio logado:", currentUser);
      }
    } catch (err) {
      console.warn("üîÅ Mensagem n√£o era JSON parse√°vel:", err);
    }
  });

  // üïí Se n√£o houver login ap√≥s 3s, assume an√¥nimo
  setTimeout(() => {
    if (!currentUser) {
      currentUser = {
        email: "anon@local",
        nick: "visitante",
        memberId: null
      };
      console.warn("‚ö†Ô∏è Modo visitante");
    }
  }, 3000);

  function triggerImageUpload() {
    console.log("üñºÔ∏è Bot√£o de upload clicado");
    const input = document.getElementById("geoImageInput");
    const modal = document.getElementById("coordModal");
    
    console.log("üîç Verificando elementos:", { 
      input: !!input, 
      modal: !!modal 
    });
    
    if (!input) {
      console.error("‚ùå Input de arquivo n√£o encontrado!");
      return;
    }
    
    if (!input.hasEventListener) {
      console.log("‚öôÔ∏è Adicionando handler ao input...");
      input.addEventListener("change", handleFileSelect);
      input.hasEventListener = true;
    }
    
    input.click();
    console.log("‚úÖ Input de arquivo acionado");
  }
  
  function handleFileSelect(e) {
    console.log("üìÅ Handler de arquivo chamado");
    const file = e.target.files[0];
    if (!file) {
      console.warn("‚ö†Ô∏è Nenhum arquivo selecionado");
      return;
    }

    console.log("üìÑ Arquivo selecionado:", file.name);

    // Verifica o tipo do arquivo
    const validTypes = ['image/jpeg', 'image/png', 'image/tiff'];
    if (!validTypes.includes(file.type)) {
      alert("Por favor, selecione uma imagem nos formatos: JPG, PNG ou TIFF");
      return;
    }

    const reader = new FileReader();
    
    reader.onload = function(evt) {
      console.log("üì∑ Imagem carregada no FileReader");
      window.currentImageURL = evt.target.result;
      
      const modal = document.getElementById("coordModal");
      console.log("üîç Procurando modal:", !!modal);
      
      if (!modal) {
        console.error("‚ùå Modal n√£o encontrado!");
        return;
      }
      
      modal.style.display = "block";
      console.log("‚úÖ Modal exibido");
      
      // Garante que os bot√µes est√£o configurados
      initModalButtons();
    };

    reader.onerror = function(evt) {
      console.error("‚ùå Erro ao ler arquivo:", evt.target.error);
      alert("Erro ao ler o arquivo. Por favor, tente novamente.");
    };

    console.log("üìñ Iniciando leitura do arquivo...");
    reader.readAsDataURL(file);
  }

  require([
    "esri/map",
    "esri/geometry/Polygon",
    "esri/geometry/webMercatorUtils",
    "esri/geometry/Extent",
    "esri/dijit/HomeButton",
    "esri/layers/WebTiledLayer",
    "esri/layers/WMSLayer",
    "esri/layers/TiledMapServiceLayer",
    "esri/toolbars/edit",
    "esri/dijit/Print",
    "esri/dijit/Legend",
    "esri/dijit/BasemapGallery",
    "esri/dijit/OverviewMap",
    "esri/dijit/TimeSlider",
    "esri/dijit/Scalebar",
    "esri/layers/ArcGISDynamicMapServiceLayer",
    "esri/dijit/Basemap",
    "esri/dijit/BasemapLayer",
    "esri/geometry/Point",
    "esri/SpatialReference",
    "esri/symbols/SimpleMarkerSymbol",
    "esri/symbols/SimpleLineSymbol",
    "esri/symbols/SimpleFillSymbol",
    "esri/Color",
    "esri/graphic",
    "esri/toolbars/draw",
    "esri/layers/MapImage",
    "esri/layers/MapImageLayer",
    "esri/config",
    "dojo/dom",
    "dojo/on",
    "dojo/dom-construct",
    "dojo/_base/declare",
    "dojo/domReady!"
  ], function(
    Map, Polygon, webMercatorUtils, Extent, HomeButton, WebTiledLayer, WMSLayer,
    TiledMapServiceLayer, edit, Print, Legend, BasemapGallery, OverviewMap, TimeSlider,
    Scalebar, ArcGISDynamicMapServiceLayer, Basemap, BasemapLayer, Point, SpatialReference,
    SimpleMarkerSymbol, SimpleLineSymbol, SimpleFillSymbol,
    Color, Graphic, Draw, MapImage, MapImageLayer, esriConfig,
    dom, on, domConstruct, declare
  ) {
    // Configura√ß√£o CORS e seguran√ßa
    esriConfig.defaults.io.corsEnabledServers.push(
      "radar.cptec.inpe.br",
      "http://radar.cptec.inpe.br",
      "https://radar.cptec.inpe.br"
    );
    
    // Desativa uso de proxy e CORS
    esriConfig.defaults.io.alwaysUseProxy = false;
    esriConfig.defaults.io.corsDetection = false;
    esriConfig.defaults.io.useCors = false;
    
    // Permite requisi√ß√µes mistas (HTTP/HTTPS)
    esriConfig.defaults.io.postMixInProperties = function() {
      this.protocol = window.location.protocol;
    };
    
    // Configura timeout mais longo para requisi√ß√µes
    esriConfig.defaults.io.timeout = 60000; // 60 segundos
    
    // Armazena classes globalmente
    window.WMSLayer = WMSLayer;

    // Define uma classe customizada para o radar CPTEC
    var CPTECRadarLayer = declare([TiledMapServiceLayer], {
      constructor: function(url, options) {
        // Chama o construtor pai
        this.inherited(arguments);
        
        // Salva as op√ß√µes
        this._url = url;
        this._options = options;
        
        // Define o ID da camada
        this.id = options.id;
        
        // Define a refer√™ncia espacial
        const sr = new SpatialReference({ wkid: 4326 });
        this.spatialReference = sr;
        
        // Define as informa√ß√µes de tile
        this.tileInfo = {
          "rows": 256,
          "cols": 256,
          "dpi": 96,
          "format": "PNG32",
          "compressionQuality": 0,
          "origin": {
            "x": -180,
            "y": 90
          },
          "spatialReference": sr,
          "lods": [
            { "level": 3, "resolution": 0.17578125, "scale": 73874398.264687508 },
            { "level": 4, "resolution": 0.087890625, "scale": 36937199.132343754 },
            { "level": 5, "resolution": 0.0439453125, "scale": 18468599.566171877 },
            { "level": 6, "resolution": 0.02197265625, "scale": 9234299.7830859385 },
            { "level": 7, "resolution": 0.010986328125, "scale": 4617149.8915429693 }
          ]
        };
        
        // Define a extens√£o espec√≠fica para o Brasil
        const extent = new Extent({
          "xmin": -75.2337,
          "ymin": -35.7213,
          "xmax": -27.5977,
          "ymax": 7.2426,
          "spatialReference": sr
        });
        
        this.initialExtent = extent;
        this.fullExtent = extent;
        
        // Define a opacidade
        this.opacity = options.opacity || 0.8;
        
        // Carrega a camada
        this.loaded = true;
        this.onLoad(this);
      },
      
      getTileUrl: function(level, row, col) {
        try {
          const bbox = this._getTileBBox(level, row, col);
          const width = this.tileInfo.cols;
          const height = this.tileInfo.rows;
          
          // Constr√≥i a URL do WMS
          const url = this._url +
            "?service=WMS" +
            "&version=1.1.1" +
            "&request=GetMap" +
            "&layers=" + this._options.layerId +
            "&styles=" +
            "&bbox=" + bbox +
            "&width=" + width +
            "&height=" + height +
            "&srs=EPSG:4326" +
            "&format=image/png" +
            "&transparent=true" +
            "&time=" + new Date().getTime(); // Evita cache
            
          console.log("üîç Requisitando tile:", {
            level: level,
            row: row,
            col: col,
            bbox: bbox,
            url: url
          });
          
          return url;
        } catch (err) {
          console.error("‚ùå Erro ao gerar URL do tile:", err);
          return "";
        }
      },
      
      _getTileBBox: function(level, row, col) {
        try {
          const resolution = this.tileInfo.lods[level - 3].resolution; // Ajusta o n√≠vel
          const tileWidth = this.tileInfo.cols * resolution;
          const tileHeight = this.tileInfo.rows * resolution;
          
          const minx = Math.max(-180, col * tileWidth - 180);
          const maxy = Math.min(90, 90 - row * tileHeight);
          const maxx = Math.min(180, minx + tileWidth);
          const miny = Math.max(-90, maxy - tileHeight);
          
          // Formata com 6 casas decimais
          return [
            minx.toFixed(6),
            miny.toFixed(6),
            maxx.toFixed(6),
            maxy.toFixed(6)
          ].join(",");
        } catch (err) {
          console.error("‚ùå Erro ao calcular BBOX:", err);
          return "-75.233700,-35.721300,-27.597700,7.242600"; // Brasil
        }
      }
    });

    // Fun√ß√£o para adicionar camada do radar CPTEC
    window.addCPTECRadar = function(radarId, type) {
      const layerId = window.CPTEC_LAYERS[type][radarId];
      console.log(`üéØ Adicionando camada ${layerId}...`);
      
      // Remove camada anterior se existir
      if (window.cptecLayers?.[layerId]) {
        window.map.removeLayer(window.cptecLayers[layerId]);
      }

      try {
        console.log("üîÑ Iniciando carregamento da camada:", layerId);
        
        // Cria nova camada usando a classe customizada
        const layer = new CPTECRadarLayer("http://radar.cptec.inpe.br/geoserver/wms", {
          id: layerId,
          layerId: layerId,
          opacity: 0.8
        });

        // Adiciona handler de erro para a camada
        layer.on("error", function(error) {
          console.error("‚ùå Erro ao carregar camada do radar:", error);
        });

        // Adiciona handler para quando a camada estiver pronta
        layer.on("load", function() {
          console.log("‚úÖ Camada do radar carregada com sucesso:", layerId);
        });

        // Adiciona handler para erros de carregamento de tiles
        layer.on("error-image-load", function(error) {
          console.warn("‚ö†Ô∏è Erro ao carregar tile:", error);
        });

        // Define a extens√£o
        const extent = new Extent({
          xmin: -60,
          ymin: -35,
          xmax: -45,
          ymax: -20,
          spatialReference: new SpatialReference({ wkid: 4326 })
        });
        layer.initialExtent = extent;
        layer.fullExtent = extent;

        // Armazena refer√™ncia da camada
        if (!window.cptecLayers) window.cptecLayers = {};
        window.cptecLayers[layerId] = layer;

        // Adiciona ao mapa
        window.map.addLayer(layer);
        console.log(`‚úÖ Camada ${layerId} adicionada com sucesso`);
      } catch (err) {
        console.error(`‚ùå Erro ao adicionar camada ${layerId}:`, err);
      }
    };

    // Armazena classes globalmente
    window.WMSLayer = WMSLayer;
    window.Extent = Extent;

    // Vari√°veis globais
    window.map = new Map("mapDiv", {
      basemap: "topo",
      center: [-49.5, -24.75],
      zoom: 6,
      sliderStyle: "small"
    });

    window.imageOverlay = null;
    window.currentImageURL = null;

    const editToolbar = new edit(window.map); // ‚úÖ cria√ß√£o correta do EditToolbar

    // ‚úÖ Layer √∫nica para os relatos
    const relatosLayer = new esri.layers.GraphicsLayer({ id: "relatosLayer" });

    // ‚úÖ Evita duplicar o layer se j√° estiver no mapa
    if (!window.map.getLayer("relatosLayer")) {
      window.map.addLayer(relatosLayer);
    }

    window.relatosLayer = relatosLayer;

    // ‚òî RainViewer Layer
    let radarLayer = null; // ser√° criado depois

    // üîÑ Atualiza com o frame mais recente
    fetch('https://api.rainviewer.com/public/weather-maps.json')
      .then(res => res.json())
      .then(data => {
        const host   = data.host;
        const frames = [...(data.radar.past || []), ...(data.radar.nowcast || [])];

        if (!frames.length) {
          console.warn('RainViewer: sem frames dispon√≠veis');
          return;
        }

        const latest = frames[frames.length - 1];
        const path   = latest.path;
        const color  = 5;     // NEXRAD color scheme
        const opts   = '0_0'; // No smoothing, no snow

        const urlTemplate = `${host}${path}/256/{level}/{col}/{row}/${color}/${opts}.png`;

        // ‚ö†Ô∏è Cria camada s√≥ ap√≥s URL estar dispon√≠vel
        radarLayer = new WebTiledLayer(urlTemplate, {
          id: "rainviewer",
          visible: false,
          copyright: "RainViewer"
        });
        window.map.addLayer(radarLayer);

        console.log("‚úÖ RainViewer carregado:", urlTemplate);
      })
      .catch(err => {
        console.error('‚ùå Erro ao carregar RainViewer:', err);
      });

    // ‚öôÔ∏è Cria div flutuante pro display das coordenadas
    const hud = document.getElementById("hudOverlay");

    window.map.on("mouse-move", function(evt) {
      if (evt && evt.mapPoint) {
        const lon = evt.mapPoint.x.toFixed(5);
        const lat = evt.mapPoint.y.toFixed(5);
        document.getElementById("hudOverlay").innerHTML = `üìç ${lon}, ${lat}¬∞`;
      }
    });
     // üß± Escala (Scalebar)
    var scalebarDiv = document.createElement("div");
    scalebarDiv.style.cssText = `
      position: fixed;
      bottom: 80px;
      left: 320px;
      background: rgba(255,255,255,0.9);
      padding: 4px 10px;
      font-family: sans-serif;
      font-size: 11px;
      border-radius: 4px;
      box-shadow: 0 0 4px rgba(0,0,0,0.2);
      z-index: 9999;
    `;
    document.body.appendChild(scalebarDiv);

    new Scalebar({
      map: window.map,
      scalebarUnit: "dual",
      attachTo: "bottom-left"
    }, scalebarDiv);

    // Inicializa os widgets do mapa
    window.map.on("load", function() {
      console.log("üó∫Ô∏è Mapa carregado, inicializando componentes...");
      
      try {
        // Adiciona controles do CPTEC
        if (typeof window.addCPTECControls === 'function') {
          window.addCPTECControls();
          console.log("‚úÖ Controles CPTEC adicionados");
        } else {
          console.warn("‚ö†Ô∏è Fun√ß√£o addCPTECControls n√£o encontrada");
        }
        
        // Inicializa a legenda
        new Legend({
          map: window.map,
          layerInfos: [{
            layer: damageLayer,
            title: "NOAA Damage Viewer"
          }]
        }, "legendDiv").startup();

        // Custom Basemaps
        var esriImagery = new Basemap({
            layers: [new BasemapLayer({
                url: "https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer"
            })],
            id: "esriImagery",
            title: "Imagery",
            thumbnailUrl: "https://www.arcgis.com/sharing/rest/content/items/10df2279f9684e4a9f6a7f08febac2a9/info/thumbnail/ago_downloaded.jpg"
        });
        var esriImageryWithLabels = new Basemap({
            layers: [new BasemapLayer({
                url: "https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer"
            }), new BasemapLayer({
                url: "https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer"
            })],
            id: "esriImageryWithLabels",
            title: "Imagery with Labels",
            thumbnailUrl: "https://www.arcgis.com/sharing/rest/content/items/413fd05bbd7342f5991d5ec96f4e4b10/info/thumbnail/imagery_labels.jpg"
        });
        var esriStreets = new Basemap({
            layers: [new BasemapLayer({
                url: "https://services.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer"
            })],
            id: "esriStreets",
            title: "Streets",
            thumbnailUrl: "https://www.arcgis.com/sharing/rest/content/items/d8855ee4d3d74413babfb0f41203b168/info/thumbnail/world_street_map.jpg"
        });
        var esriTopo = new Basemap({
            layers: [new BasemapLayer({
                url: "https://services.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer"
            })],
            id: "esriTopo",
            title: "Topographic",
            thumbnailUrl: "https://www.arcgis.com/sharing/rest/content/items/30e5fe3149c34df1ba922e6f5bbf808f/info/thumbnail/topo_map_2.jpg"
        });
        var esriDarkGray = new Basemap({
             layers: [new BasemapLayer({
                url: "https://services.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Dark_Gray_Base/MapServer"
            })],
            id: "esriDarkGray",
            title: "Dark Gray Canvas",
            thumbnailUrl: "https://www.arcgis.com/sharing/rest/content/items/a284a9b99b3446a3910d4325e8c61582/info/thumbnail/dark_gray_canvas_2.jpg"
        });
        var esriOceans = new Basemap({
             layers: [new BasemapLayer({
                url: "https://services.arcgisonline.com/ArcGIS/rest/services/Ocean/World_Ocean_Base/MapServer"
            })],
            id: "esriOceans",
            title: "Oceans",
            thumbnailUrl: "https://www.arcgis.com/sharing/rest/content/items/c9b7e98059534a7894d334585c36398f/info/thumbnail/Oceans_Basemap_6_7.png"
        });

        // Inicializa galeria de mapas base
        new BasemapGallery({
          showArcGISBasemaps: false,
          basemaps: [esriImagery, esriImageryWithLabels, esriStreets, esriTopo, esriDarkGray, esriOceans],
          map: window.map
        }, "basemapGalleryDiv").startup();

        // Atualiza legenda de riscos
        updateRiskLegend();

        // Inicializa mapa de vis√£o geral
        new OverviewMap({
          map: window.map,
          visible: true
        }, "overviewMapDiv").startup();

        // Inicializa bot√£o home
        new HomeButton({
          map: window.map
        }, "homeButtonDiv").startup();

        // Inicializa impress√£o
        new Print({
          map: window.map,
          url: "https://utility.arcgisonline.com/arcgis/rest/services/Utilities/PrintingTools/GPServer/Export%20Web%20Map%20Task"
        }, "printDiv").startup();

        // Inicializa os handlers dos bot√µes do modal
        window.initModalButtons();

        console.log("‚úÖ Todos os componentes do mapa inicializados");
      } catch (err) {
        console.error("‚ùå Erro ao inicializar componentes:", err);
      }
    });

    // Inicializa os event listeners dos checkboxes
    function initCheckboxListeners() {
      console.log("üîÑ Inicializando event listeners dos checkboxes...");
      
      const checkboxes = ["chkPoints", "chkLines", "chkPolygons"];
      checkboxes.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
          element.addEventListener("change", updateVis);
          console.log(`‚úÖ Listener adicionado para ${id}`);
        } else {
          console.warn(`‚ö†Ô∏è Elemento ${id} n√£o encontrado`);
        }
      });
    }

    // Fun√ß√£o para atualizar visibilidade das camadas
    function updateVis() {
      console.log("üîÑ Atualizando visibilidade das camadas...");
      
      try {
        const arr = [];
        const elements = {
          chkPoints: document.getElementById("chkPoints"),
          chkLines: document.getElementById("chkLines"),
          chkPolygons: document.getElementById("chkPolygons")
        };

        if (elements.chkPoints?.checked) arr.push(0);
        if (elements.chkLines?.checked) arr.push(1);
        if (elements.chkPolygons?.checked) arr.push(2);

        damageLayer.setVisibleLayers(arr);
        console.log("‚úÖ Visibilidade atualizada:", arr);
      } catch (err) {
        console.error("‚ùå Erro ao atualizar visibilidade:", err);
      }
    }

    // Inicializa os listeners quando o documento estiver pronto
    document.addEventListener("DOMContentLoaded", function() {
      console.log("üìÑ Documento carregado, inicializando listeners...");
      initCheckboxListeners();
    });

    let brazilBoundary = null;

    fetch("https://cdn.jsdelivr.net/gh/LucasMouraChaser/brasilunificado@main/brasilunificado.geojson")
      .then(res => res.json())
      .then(data => {
        // Extrai o primeiro Feature v√°lido com tipo Polygon/MultiPolygon
        const firstValid = data.features.find(f =>
          f.geometry?.type === "Polygon" || f.geometry?.type === "MultiPolygon"
        );

        if (!firstValid) throw new Error("‚ùå Nenhum pol√≠gono v√°lido no GeoJSON");

        // Marca como pronto e define o contorno global
        brazilBoundary = firstValid;
        brazilBoundaryReady = true;
        console.log("‚úÖ Contorno do Brasil carregado via jsDelivr");
      })
      .catch(err => console.error("‚ùå Erro ao carregar contorno do Brasil:", err));

    const catColor = {
      0: "#00FF00",
      1: "#FFFF00",
      2: "#FFA500",
      3: "#FF0000",
      4: "#800080"
    };

    fetch("https://cdn.jsdelivr.net/gh/LucasMouraChaser/simplaoosmunicipio@bb3e7071319f8e42ffd24513873ffb73cce566e6/brazil-mun.simplao.geojson")
      .then(res => res.json())
      .then(data => {
        const municipioGraphics = data.features.map(f => new Graphic(
          new Polygon({
            rings: f.geometry.coordinates,
            spatialReference: { wkid: 4326 }
          }),
          new SimpleFillSymbol(
            SimpleFillSymbol.STYLE_NULL,
            new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color([0, 0, 0, 0.3]), 1),
            null
          )
        ));

        const featureLayer = new esri.layers.GraphicsLayer({ id: "municipios" });
        municipioGraphics.forEach(g => featureLayer.add(g));

        window.map.addLayer(featureLayer);
        featureLayer.setVisibility(false);
        window.municipiosLayer = featureLayer;
        console.log("‚úÖ Munic√≠pios carregados");
      });
      
    function levelOf(prob, type) {
      return type === 'tornado'
        ? {2:1, 5:2, 10:3, 15:4}[prob] || 0
        : {5:1, 15:2, 30:3, 45:4}[prob] || 0;
    }

    function setForecastView(mode) {
      forecastMode = mode;
      document.getElementById("choiceDlg").style.display = "none";

      // remove gr√°ficos anteriores
      clearForecastPolygons();

      const legendPrevots = document.getElementById("legendPrevots");
      const legendRisk = document.getElementById("legendRisk");

      if (mode === "overall") {
        // Modo Mapa Geral
        legendPrevots.style.display = "block";     // ‚úÖ mostra PREVOTS
        legendRisk.style.display = "none";         // ‚ùå esconde risco
      } else {
        legendPrevots.style.display = "none";      // ‚ùå esconde PREVOTS
        legendRisk.style.display = "block";        // ‚úÖ mostra risco
      }

      // solicita a previs√£o do backend
      const dateISO = document.getElementById("startDate").value || new Date().toISOString().slice(0, 10);
      window.parent.postMessage({
        action: "requestForecast",
        data: { dateISO }
      }, "*");
    }

    window.setForecastView = function(mode) {
      forecastMode = mode;
      document.getElementById("choiceDlg").style.display = "none";

      clearForecastPolygons();

      const legendPrevots = document.getElementById("legendPrevots");
      const legendRisk = document.getElementById("legendRisk");

      if (mode === "overall") {
        legendPrevots.style.display = "block";
        legendRisk.style.display = "none";
      } else {
        legendPrevots.style.display = "none";
        legendRisk.style.display = "block";
      }

      const dateISO = document.getElementById("startDate").value || new Date().toISOString().slice(0, 10);

      const hazard = mode === "all" ? document.getElementById("hazardSel").value : "*";

      // üß† Solicita previs√£o com filtro
      window.parent.postMessage({
        action: "requestForecast",
        data: {
          dateISO,
          hazard // granizo | vento | tornado | "*" para mosaico
        }
      }, "*");
    };

    function renderForecastPolygons(fc) {
      clearForecastPolygons();

      if (!fc?.features?.length) {
        console.warn("‚ö†Ô∏è Nenhuma feature no forecast");
        return;
      }

      console.log("üìå Renderizando", fc.features.length, "pol√≠gonos"); // ‚úÖ debug

      if (forecastMode === "overall") {
        const merged = turf.union(...fc.features);
        if (!merged) return;

        const rings = merged.geometry.coordinates[0];
        const polygon = new Polygon({ rings, spatialReference: { wkid: 4326 } });
        const symbol = new SimpleFillSymbol(
          SimpleFillSymbol.STYLE_SOLID,
          new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color("#00cfff"), 2),
          new Color([0, 207, 255, 0.3])
        );
        const graphic = new Graphic(polygon, symbol);
        window.map.graphics.add(graphic);
        forecastGraphics.push(graphic);
        return;
      }

      // modo "todos os riscos"
      fc.features.forEach(f => {
        if (f.geometry?.type !== "Polygon") return;
        const rings = f.geometry.coordinates[0];
        const polygon = new Polygon({ rings, spatialReference: { wkid: 4326 } });

        const hazard = f.properties?.type || "hail";
        const level  = f.properties?.level || 0;
        const color  = catColor[level] || "#999";

        const symbol = new SimpleFillSymbol(
          SimpleFillSymbol.STYLE_DIAGONAL_CROSS,
          new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color(color), 2),
          new Color([...hexToRgb(color), 0.25])
        );

        const g = new Graphic(polygon, symbol);
        window.map.graphics.add(g);
        forecastGraphics.push(g);
      });
    }

    function clearForecastPolygons() {
      forecastGraphics.forEach(g => window.map.graphics.remove(g));
      forecastGraphics = [];
    }
    const polygonGroups = {
      hail: [],
      wind: [],
      tornado: []
    };

    function togglePolygonsByRisk(selected) {
      Object.entries(polygonGroups).forEach(([risk, group]) => {
        group.forEach(g => g.setVisibility(risk === selected));
      });
    }

    function carregarRelatosPorData(dateISO) {
      const endpoint = `https://www.brazilstormchase.com.br/teste/_functions/reports/list?date=${dateISO}`;

      fetch(endpoint)
        .then(res => res.json())
        .then(data => {
          if (!data.features || !data.features.length) {
            console.log("üì≠ Nenhum relato encontrado para:", dateISO);
            relatosLayer.clear();
            return;
          }

          relatosLayer.clear();

          data.features.forEach(f => {
            const [lon, lat] = f.geometry.coordinates;
            const props = f.properties || {};
            const pt = new Point(lon, lat, new SpatialReference({ wkid: 4326 }));
            const symbol = getIconSymbol(props.hazard, props.sev);

            const g = new Graphic(pt, symbol, props);
            relatosLayer.add(g);
          });

          console.log(`‚úÖ ${data.features.length} relatos adicionados para ${dateISO}`);
        })
        .catch(err => {
          console.error("‚ùå Erro ao buscar relatos:", err);
        });
    }

    function carregarRelatosHoje() {
      const hoje = new Date().toISOString().slice(0, 10);
      const endpoint = `https://www.brazilstormchase.com.br/teste/_functions/reports/list?date=${hoje}`;

      fetch(endpoint)
        .then(res => res.json())
        .then(data => {
          relatosLayer.clear();

          data.features.forEach(f => {
            const [lon, lat] = f.geometry.coordinates;
            const pt = new Point(lon, lat, new SpatialReference({ wkid: 4326 }));

            const symbol = getIconSymbol(f.properties.hazard, f.properties.sev);
            const g = new Graphic(pt, symbol, f.properties);

            relatosLayer.add(g);
          });

          console.log(`‚úÖ ${data.features.length} relatos carregados`);
        })
        .catch(err => {
          console.error("‚ùå Erro ao carregar relatos do CMS", err);
        });
    }

    function getIconSymbol(hazard, sev = "NOR") {
      const key = `${hazard.toLowerCase()}|${(sev || "NOR").toUpperCase()}`;
      const iconMap = {
        'vento|NOR':   'https://static.wixstatic.com/media/c003a9_38c6ec164e3742dab2237816e4ff8c95~mv2.png',
        'vento|SS':    'https://static.wixstatic.com/media/c003a9_3fc6c303cb364c5db3595e4203c1888e~mv2.png',
        'granizo|NOR': 'https://static.wixstatic.com/media/c003a9_70be04c630a64abca49711a423da779b~mv2.png',
        'granizo|SS':  'https://static.wixstatic.com/media/c003a9_946684b74c234c2287a153a6b6c077fe~mv2.png',
        'tornado|NOR': 'https://static.wixstatic.com/media/c003a9_9f22188e065e4424a1f8ee3a3afeffde~mv2.png',
        'tornado|SS':  'https://static.wixstatic.com/media/c003a9_3a647b1160024b55bb3ecc148df1309f~mv2.png'
      };

      const iconUrl = iconMap[key] || iconMap['vento|NOR']; // fallback
      return new esri.symbol.PictureMarkerSymbol(iconUrl, 20, 20);
    }

    window.resetMap = function () {
      window.map.setExtent(new Extent({
        xmin: -60.5,
        ymin: -33.0,
        xmax: -38.5,
        ymax: -16.5,
        spatialReference: { wkid: 4326 }
      }));
    };

    var damageLayer = new ArcGISDynamicMapServiceLayer(
      "https://services.dat.noaa.gov/arcgis/rest/services/nws_damageassessmenttoolkit/DamageViewer/MapServer",
      { 
        id: "damageLayer",
        opacity: 0.7,
        visible: true
      }
    );

    window.map.addLayer(damageLayer);

    window.map.on("layers-add-result", function(evt){
      var info = evt.layers[0].layer.timeInfo;
      if (!info) return;
      var slider = new TimeSlider({ style: "width:100%;" }, "timeSliderDiv");
      window.map.setTimeSlider(slider);
      slider.setThumbCount(2);
      slider.createTimeStopsByTimeInterval(info.timeExtent, 1, "days");
      slider.setThumbMovingRate(2000);
      slider.startup();
      on(slider, "time-extent-change", function(evt){
        damageLayer.setTimeDefinition(evt.startTime, evt.endTime);
      });
    });

    var visible = [0,1,2];
    damageLayer.setVisibleLayers(visible);

    // üîç Busca por endere√ßo
    var searchMarker = null;
    var input = document.getElementById("searchInput");
    input.addEventListener("keypress", function(e) {
      if (e.key === "Enter") {
        var query = input.value.trim();
        if (!query) return;

        fetch("https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/findAddressCandidates?SingleLine=" + encodeURIComponent(query) + "&f=json")
          .then(res => res.json())
          .then(data => {
            if (!data.candidates || data.candidates.length === 0) {
              alert("‚ùå Nenhum endere√ßo encontrado.");
              return;
            }

            var best = data.candidates[0];
            var pt = new Point(best.location.x, best.location.y, new SpatialReference({ wkid: 4326 }));
            window.map.centerAndZoom(pt, 12);

            if (searchMarker) window.map.graphics.remove(searchMarker);

            var symbol = new SimpleMarkerSymbol()
              .setColor(new Color([255, 0, 0, 0.75]))
              .setSize(12)
              .setOutline(new SimpleLineSymbol().setColor(new Color([255,255,255])));

            var graphic = new Graphic(pt, symbol);
            window.map.graphics.add(graphic);
            searchMarker = graphic;

            setTimeout(() => {
              window.map.infoWindow.setTitle("Resultado");
              window.map.infoWindow.setContent(best.address);
              window.map.infoWindow.show(pt);
            }, 300);
          });
      }
    });

    // ‚õ∂ Tela cheia
    window.toggleFullscreen = function () {
      const el = document.documentElement;
      if (!document.fullscreenElement) {
        el.requestFullscreen().catch(err => alert("Erro ao entrar em tela cheia."));
      } else {
        document.exitFullscreen();
      }
    };

    // ‚¨¢ Desenhar pol√≠gono
    var drawToolbar = new Draw(window.map);
    var polygonSymbol = new SimpleFillSymbol(
      SimpleFillSymbol.STYLE_SOLID,
      new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color([0, 0, 255]), 2),
      new Color([0, 100, 255, 0.25])
    );

    let pendingGeometry = null;
    let blockPopupClick = false;

    drawToolbar.on("draw-complete", function(evt) {
      drawToolbar.deactivate();
      isDrawing = false; // üëà pronto, terminou de desenhar

      // üõ°Ô∏è Protege contra clique herdado do final do desenho
      blockPopupClick = true;
      setTimeout(() => blockPopupClick = false, 300);

      const hazard = document.getElementById("hazardSel").value;
      const prob = +document.getElementById("probSel").value;
      const level = levelOf(prob, hazard);
      const color = catColor[level] || "#888";

      if (!brazilBoundary) {
        alert("‚è≥ Contorno do Brasil ainda n√£o est√° pronto.");
        return;
      }

      // Converte para EPSG:4326
      const geom4326 = webMercatorUtils.webMercatorToGeographic(evt.geometry);

      const turfPolygon = {
        type: "Feature",
        geometry: {
          type: "Polygon",
          coordinates: geom4326.rings.map(ring =>
            ring.map(([x, y]) => [parseFloat(x), parseFloat(y)])
          )
        },
        properties: {}
      };

      const clipped = turf.intersect(turfPolygon, brazilBoundary);
      if (!clipped) {
        alert("‚ö†Ô∏è Previs√£o √© feita apenas para o Brasil.");
        return;
      }

      const newArea = turf.area(clipped); // em m¬≤
      const sameHazardPolys = polygonGroups[hazard] || [];

      // ‚ö†Ô∏è Verifica se algum pol√≠gono menor j√° existente tem n√≠vel mais baixo
      for (let p of sameHazardPolys) {
        const existingLevel = p.attributes?.level;
        if (existingLevel == null || existingLevel >= level) continue;

        const geo = p.geometry.toJson();
        const turfPoly = {
          type: "Feature",
          geometry: {
            type: "Polygon",
            coordinates: geo.rings
          }
        };

        const existingArea = turf.area(turfPoly);

        if (newArea > existingArea) {
          alert("üö´ Um pol√≠gono de n√≠vel maior n√£o pode ser maior que um de n√≠vel menor.");
          return;
        }
      }

      const symbol = new SimpleFillSymbol(
        SimpleFillSymbol.STYLE_SOLID,
        new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color(color), 2),
        new Color([...hexToRgb(color), 0.25])
      );

      const clippedGraphic = new Graphic(
        new Polygon({
          rings: clipped.geometry.coordinates,
          spatialReference: { wkid: 4326 }
        }),
        symbol
      );

      clippedGraphic.setAttributes({ hazard, level, prob });
      clippedGraphic._editing = false;

      // Adiciona ao grupo e mapa
      polygonGroups[hazard].push(clippedGraphic);
      window.map.graphics.add(clippedGraphic);

      // Clique para abrir popup (com prote√ß√£o de edi√ß√£o ativa)
      clippedGraphic.onClick = function(evt) {
        if (window.map._selectedGraphic && window.map._selectedGraphic._editing) return;
        showPolygonPopup(evt.graphic);
      };
    });

    window.map.on("click", function(evt) {
      if (isDrawing) {
        console.log("‚õî Ignorado: clique durante desenho ativo");
        return;
      }

      const g = evt.graphic;
      if (!g || !g.attributes) return;

      if (g.geometry?.type === "polygon") {
        showPolygonPopup(g);
        window.map._selectedGraphic = g;
      }
    });

    // üí° Modo de troca por risco
    function togglePolygonsByRisk(selected) {
      Object.entries(polygonGroups).forEach(([risk, polys]) => {
        polys.forEach(g => {
          if (risk === selected) {
            window.map.graphics.add(g);
          } else {
            window.map.graphics.remove(g);
          }
        });
      });
    }

    window.activatePolygonDraw = function () {
      if (!brazilBoundaryReady) {
        alert("‚è≥ Aguarde: limites do Brasil ainda est√£o carregando...");
        return;
      }

      isDrawing = true; // üëà agora estamos desenhando
      drawToolbar.activate(Draw.POLYGON);
    };

    window.cancelForecast = function () {
      pendingGeometry = null;
      document.getElementById("forecastModal").style.display = "none";
    };

    window.confirmForecast = function () {
      if (!pendingGeometry) return;

      const geo = {
        type: "Feature",
        geometry: pendingGeometry.toJson(),
        properties: {}
      };

      const today = new Date();
      const dateISO = today.toISOString().slice(0,10);
      const dayType = document.getElementById("dayType").value;

      const message = {
        action: "saveForecast",
        data: {
          dateISO,
          dayType,
          geojson: geo
        }
      };

      window.parent.postMessage(JSON.stringify(message), "*");

      document.getElementById("forecastModal").style.display = "none";
      pendingGeometry = null;
    };
    function updateProbabilities() {
      const hazard = document.getElementById("hazardSel").value;
      const probs = { hail:[5,15,30,45], wind:[5,15,30,45], tornado:[2,5,10,15] }[hazard];
      const probSel = document.getElementById("probSel");
      probSel.innerHTML = probs.map(p => `<option value="${p}">${p}</option>`).join('');
    }
    updateProbabilities();
    document.getElementById("hazardSel").addEventListener("change", function () {
      updateProbabilities();
      updateRiskLegend();
      togglePolygonsByRisk(this.value); // ativa apenas o grupo vis√≠vel
    });

    function sendForecast() {
      const dateISO = document.getElementById("startDate").value || new Date().toISOString().slice(0, 10);
      const dayType = document.getElementById("dayType")?.value || "hoje";

      if (!currentUser?.email) {
        alert("‚ö†Ô∏è Fa√ßa login para enviar sua previs√£o.");
        return;
      }

      const fc = {
        type: "FeatureCollection",
        features: []
      };

      Object.entries(polygonGroups).forEach(([hazard, group]) => {
        group.forEach(g => {
          const gj = g.geometry.toJson();
          const f = {
            type: "Feature",
            geometry: {
              type: "Polygon",
              coordinates: gj.rings,
            },
            properties: {
              type: hazard,
              level: g.attributes?.level || 0,
              prob: g.attributes?.prob || 0
            }
          };
          fc.features.push(f);
        });
      });

      if (!fc.features.length) {
        alert("‚ö†Ô∏è Nenhum pol√≠gono foi desenhado.");
        return;
      }

      // üì¶ Payload completo para o backend
      const payload = {
        action: "saveForecast",
        data: {
          dateISO,
          dayType,
          geojson: fc,
          memberId: currentUser.memberId || null,
          nick: currentUser.nick,
          email: currentUser.email
        }
      };

      window.parent.postMessage(JSON.stringify(payload), "*");

      // ‚úÖ Popup visual bonito
      const dialog = document.createElement("div");
      dialog.innerHTML = `<div style="
        position:fixed; top:50%; left:50%;
        transform:translate(-50%,-50%);
        background:#262626; color:white; padding:16px 24px;
        border-radius:8px; box-shadow:0 0 10px black;
        z-index:10000; font-family:sans-serif; text-align:center;
      ">
        ‚úÖ Previs√£o enviada com sucesso!<br><br>
        <button onclick="this.parentElement.remove()" style="
          margin-top:12px; padding:6px 16px; border:none;
          background:#00cfff; color:white; border-radius:4px;
          cursor:pointer;">Fechar</button>
      </div>`;
      document.body.appendChild(dialog);
    }

    function updateRiskLegend() {

      const probsByType = {
        hail:    [5,15,30,45],
        wind:    [5,15,30,45],
        tornado: [2,5,10,15]
      };

      const type = document.getElementById("hazardSel").value;
      const probs = probsByType[type] || [];
      const div = document.getElementById("legendItems");

      div.innerHTML = probs.map(p => {
        const lvl = levelOf(p, type);
        const color = catColor[lvl] || "#999";
        return `<div style="margin-bottom:4px">
          <span style="display:inline-block;width:14px;height:14px;background:${color};margin-right:6px;border-radius:2px;"></span>
          ${p}% (N√≠vel ${lvl})
        </div>`;
      }).join('');
    }
    const polyColors = {
      hail: "#007fff",
      wind: "#ff9900",
      tornado: "#cc0033"
    };

    function showPolygonPopup(graphic) {
      const popupData = graphic.attributes || {};
      const center = graphic.geometry.getExtent().getCenter();

      window.map.infoWindow.setTitle("Pol√≠gono");
      window.map.infoWindow.setContent(`
        <b>Tipo:</b> ${popupData.hazard || 'N/A'}<br>
        <b>N√≠vel:</b> ${popupData.level || 'N/A'}<br>
        <b>Probabilidade:</b> ${popupData.prob || 'N/A'}%<br><br>
        <button onclick="editPoly()">‚úèÔ∏è Editar</button>
        <button onclick="confirmEdit()">‚úÖ Confirmar</button>
        <button onclick="deletePoly()">üóëÔ∏è Excluir</button>
      `);
      window.map.infoWindow.show(center);
      window.map._selectedGraphic = graphic;
    }

    window.editPoly = function () {
      const g = window.map._selectedGraphic;
      if (!g) return;

      g._editing = true;

      drawToolbar.activate(Draw.EDIT_VERTICES | Draw.MOVE, g);
      window.map.infoWindow.hide();

      // ‚úÖ Remove eventos antigos se existirem
      if (g._clickHandle) {
        g._clickHandle.remove();
        g._clickHandle = null;
      }

      // ‚úÖ Adiciona listener que permite clicar novamente no pol√≠gono
      g._clickHandle = on(g.getShape(), "click", function () {
        if (g._editing) {
          confirmEdit();  // finaliza a edi√ß√£o
        }
      });
    }

    window.confirmEdit = function () {
      const g = window.map._selectedGraphic;
      if (!g) return;

      g._editing = false;
      drawToolbar.deactivate();

      const hazard = g.attributes?.hazard;
      const color = polyColors[hazard] || "#666";

      g.setSymbol(
        new SimpleFillSymbol(
          SimpleFillSymbol.STYLE_SOLID,
          new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color(color), 2),
          new Color([...hexToRgb(color), 0.25])
        )
      );

      window.map.infoWindow.hide();

      // üîÑ Atualiza o clique padr√£o para popup novamente
      if (g._clickHandle) {
        g._clickHandle.remove();
      }

      g._clickHandle = on(g.getShape(), "click", function (evt) {
        if (!g._editing) {
          showPolygonPopup(g);
        }
      });
    };

    window.deletePoly = function () {
      const g = window.map._selectedGraphic;
      if (!g) return;

      g._editing = false;
      const hazard = g.attributes?.hazard;

      window.map.graphics.remove(g);
      if (hazard && polygonGroups[hazard]) {
        polygonGroups[hazard] = polygonGroups[hazard].filter(p => p !== g);
      }

      window.map.infoWindow.hide();
      window.map._selectedGraphic = null;
    };

    // Mostra o popup com bot√µes
    function showPolygonPopup(graphic) {
      const popupData = graphic.attributes || {};
      const center = graphic.geometry.getExtent().getCenter();

      window.map.infoWindow.setTitle("Pol√≠gono");
      window.map.infoWindow.setContent(`
        <b>Tipo:</b> ${popupData.hazard || 'N/A'}<br>
        <b>N√≠vel:</b> ${popupData.level || 'N/A'}<br>
        <b>Probabilidade:</b> ${popupData.prob || 'N/A'}%<br><br>
        <button onclick="editPoly()">‚úèÔ∏è Editar</button>
        <button onclick="confirmEdit()">‚úÖ Confirmar</button>
        <button onclick="deletePoly()">üóëÔ∏è Excluir</button>
      `);
      window.map.infoWindow.show(center);
      window.map._selectedGraphic = graphic;
    }

    function hexToRgb(hex) {
      hex = hex.replace("#", "");
      return [
        parseInt(hex.substring(0,2), 16),
        parseInt(hex.substring(2,4), 16),
        parseInt(hex.substring(4,6), 16)
      ];
    }

    document.getElementById("toggleRainviewer").addEventListener("change", function(e) {
      if (radarLayer) {
        radarLayer.setVisibility(e.target.checked);
      } else {
        alert("‚ö†Ô∏è Radar ainda n√£o carregado.");
      }
    });

    document.getElementById("toggleMunicipios").addEventListener("change", function(e) {
      if (window.municipiosLayer) {
        window.municipiosLayer.setVisibility(e.target.checked);
      }
    });

    document.getElementById("chkPoints").addEventListener("change", function(e) {
      if (e.target.checked) {
        carregarRelatosHoje();
        relatosLayer.setVisibility(true);
      } else {
        relatosLayer.setVisibility(false);
      }
    });

    document.getElementById("submitDate").addEventListener("click", function () {
      const dateISO = document.getElementById("startDate").value;
      if (!dateISO) {
        alert("Selecione uma data para buscar relatos.");
        return;
      }

      // Envia solicita√ß√£o para o parent (Wix)
      window.parent.postMessage({
        action: "fetchReports",
        data: { dateISO }
      }, "*");
    });

    document.getElementById("btnSubmitForecast").addEventListener("click", function () {
      sendForecast();
    });

    const chkForecastView = document.getElementById("chkForecastView");

    chkForecastView.addEventListener("change", function (e) {
      const choiceDlg = document.getElementById("choiceDlg");

      if (e.target.checked) {
        // ‚úÖ SOMENTE abre a escolha visual
        choiceDlg.style.display = "block";
      } else {
        // ‚ùå Apaga gr√°ficos, mostra legendas normais
        clearForecastPolygons();
        document.getElementById("legendPrevots").style.display = "none";
        document.getElementById("legendRisk").style.display = "block";

        // üîÑ Reativa relatos do dia
        const dateISO = document.getElementById("startDate").value || new Date().toISOString().slice(0, 10);
        window.parent.postMessage({
          action: "fetchReports",
          data: { dateISO }
        }, "*");
      }
    });

    // üëá Dentro do setForecastView, voc√™ j√° possui este trecho:
    window.setForecastView = function (mode) {
      forecastMode = mode;
      document.getElementById("choiceDlg").style.display = "none";
      clearForecastPolygons();

      const dateISO = document.getElementById("startDate").value || new Date().toISOString().slice(0, 10);
      const hazard = mode === "all" ? document.getElementById("hazardSel").value : "*";

      window.parent.postMessage({
        action: "requestForecast",
        data: {
          dateISO,
          hazard
        }
      }, "*");
    };

    window.addEventListener("message", function (evt) {
      const msg = evt.data;

      console.log("üì® Mensagem recebida via postMessage:", msg);

      if (msg.action === "reportsData") {
        const features = msg.data?.features || [];
        if (!window.relatosLayer) return;

        // üß† Reset estat√≠sticas
        const stats = {
          total: 0,
          sig: 0,
          hail: 0,
          wind: 0,
          tornado: 0,
          hailSig: 0,
          windSig: 0,
          tornadoSig: 0
        };

        relatosLayer.clear();
        const rendered = new Set();

        features.forEach(f => {
          const [lon, lat] = f.geometry.coordinates;
          const props = f.properties || {};
          const hazard = props.hazard?.toLowerCase() || "desconhecido";
          const sev = props.sev || "N/A";
          const key = `${hazard}_${lat.toFixed(5)}_${lon.toFixed(5)}`;

          if (rendered.has(key)) return;
          rendered.add(key);

          // üìä Contadores
          stats.total++;
          if (sev === 'SS') stats.sig++;

          if (hazard === 'granizo') {
            stats.hail++;
            if (sev === 'SS') stats.hailSig++;
          }
          if (hazard === 'vento') {
            stats.wind++;
            if (sev === 'SS') stats.windSig++;
          }
          if (hazard === 'tornado') {
            stats.tornado++;
            if (sev === 'SS') stats.tornadoSig++;
          }

          const pt = new Point(lon, lat, new SpatialReference({ wkid: 4326 }));
          const symbol = getIconSymbol(hazard, sev);
          const g = new Graphic(pt, symbol, props);

          // üìå Popup com infoTemplate
          g.setInfoTemplate(new esri.InfoTemplate(
            props.hazard?.toUpperCase() || 'Relato',
            `
              <b>Tipo:</b> ${props.hazard || 'N/A'}<br>
              <b>Severidade:</b> ${sev}<br>
              <b>Hora:</b> ${props.hora || 'N/A'}<br>
              <b>Lat:</b> ${pt.getLatitude().toFixed(4)}<br>
              <b>Lon:</b> ${pt.getLongitude().toFixed(4)}
            `
          ));

          relatosLayer.add(g);
        });

        console.log(`‚úÖ ${relatosLayer.graphics.length} relatos plotados com popup`);

        document.getElementById("statsContent").innerHTML = `
          <b>Total:</b> ${stats.total} (<b>${stats.sig}</b> sig)<br>
          <span style="color:#3366cc"><b>Vento:</b> ${stats.wind} (${stats.windSig} sig)</span><br>
          <span style="color:#33aa33"><b>Granizo:</b> ${stats.hail} (${stats.hailSig} sig)</span><br>
          <span style="color:#cc0033"><b>Tornado:</b> ${stats.tornado} (${stats.tornadoSig} sig)</span>
        `;
      }

      if (msg.action === "deliverForecast") {
        console.log("üì¶ Forecast recebido do backend.");

        const fc = msg.geojson;

        if (!fc || !Array.isArray(fc.features)) {
          console.warn("‚ùå Forecast inv√°lido");
          return;
        }

        if (forecastMode === "overall") {
          // Mosaico para PREV 1-4
          const merged = turf.union(...fc.features);
          if (!merged) return;

          const rings = merged.geometry.coordinates[0];
          const polygon = new Polygon({ rings, spatialReference: { wkid: 4326 } });
          const symbol = new SimpleFillSymbol(
            SimpleFillSymbol.STYLE_SOLID,
            new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color("#00cfff"), 2),
            new Color([0, 207, 255, 0.3])
          );
          const graphic = new Graphic(polygon, symbol);
          window.map.graphics.add(graphic);
          forecastGraphics.push(graphic);
        } else {
          // Filtra pelo tipo atual (granizo, vento, tornado)
          // üîÅ Corrige os valores para corresponderem com os dados salvos
          const label = document.getElementById("hazardSel").value;
          const selected = {
            granizo: "hail",
            vento: "wind",
            tornado: "tornado"
          }[label] || label;
          const filtered = fc.features.filter(f =>
            f.properties?.type?.toLowerCase() === selected.toLowerCase()
          );

          if (!filtered.length) {
            console.warn("‚ö†Ô∏è Nenhuma previs√£o do tipo selecionado.");
            return;
          }

          renderForecastPolygons({ type: "FeatureCollection", features: filtered });
        }
      }
    });
    // Inicializa canal de comunica√ß√£o
    window.parent.postMessage({ action: "ready" }, "*");

    // Verifica se todos os elementos necess√°rios existem
    document.addEventListener("DOMContentLoaded", function() {
      const requiredElements = [
        "geoImageInput",
        "coordModal",
        "toggleOverlay",
        "opacityControl",
        "opacitySlider",
        "opacityValue",
        "toggleRainviewer",
        "toggleMunicipios"
      ];

      const missingElements = requiredElements.filter(id => !document.getElementById(id));
      
      if (missingElements.length > 0) {
        console.error("‚ùå Elementos necess√°rios n√£o encontrados:", missingElements);
        return;
      }

      // Inicializa o handler de arquivo
      console.log("üîÑ Inicializando handler de arquivo...");
      
      const geoImageInput = document.getElementById("geoImageInput");
      const coordModal = document.getElementById("coordModal");
      
      if (!geoImageInput || !coordModal) {
        console.error("‚ùå Elementos necess√°rios n√£o encontrados:", {
          input: !!geoImageInput,
          modal: !!coordModal
        });
        return;
      }
      
      console.log("‚úÖ Handler de arquivo inicializado");

      // Fun√ß√£o para inicializar os handlers de imagem
      function initImageHandlers() {
        console.log("üîÑ Tentando inicializar handlers de imagem...");
        
        const geoImageInput = document.getElementById("geoImageInput");
        const coordModal = document.getElementById("coordModal");
        
        if (!geoImageInput || !coordModal) {
          console.log("‚è≥ Elementos ainda n√£o dispon√≠veis, aguardando...");
          return false;
        }

        // Remove listener antigo se existir
        if (geoImageInput.hasEventListener) {
          geoImageInput.removeEventListener("change", handleFileSelect);
        }

        console.log("‚úÖ Elementos encontrados, adicionando handlers...");
        
        geoImageInput.addEventListener("change", handleFileSelect);
        geoImageInput.hasEventListener = true;

        return true;
      }

      // Garante que o DOM est√° carregado antes de inicializar
      if (!initImageHandlers()) {
        // Se falhar, configura um observer para tentar novamente quando os elementos existirem
        const observer = new MutationObserver(function(mutations) {
          if (initImageHandlers()) {
            console.log("‚úÖ Handlers dos bot√µes inicializados com sucesso via observer!");
            observer.disconnect();
          }
        });

        observer.observe(document.body, {
          childList: true,
          subtree: true
        });
      }
    });

    // Fun√ß√µes globais para manipula√ß√£o da imagem
    window.autoLoadImage = function() {
      console.log("üîÑ Carregando imagem automaticamente...");
      if (!window.currentImageURL) {
        console.error("‚ùå Nenhuma imagem selecionada!");
        return;
      }
      
      const coords = {
        lonMin: -60.503571,
        lonMax: -38.495731,
        latMin: -33.002845,
        latMax: -16.497153
      };

      // Primeiro ajusta a visualiza√ß√£o
      const extent = new Extent({
        xmin: coords.lonMin,
        ymin: coords.latMin,
        xmax: coords.lonMax,
        ymax: coords.latMax,
        spatialReference: { wkid: 4326 }
      });

      console.log("üéØ Ajustando visualiza√ß√£o do mapa...");
      window.map.setExtent(extent.expand(1.05));

      // Aguarda um momento para o mapa se ajustar antes de carregar a imagem
      setTimeout(() => {
        window.loadImage(coords);
      }, 500);
    }

    window.loadImageWithCoords = function() {
      console.log("üìç Carregando imagem com coordenadas manuais...");
      if (!window.currentImageURL) {
        console.error("‚ùå Nenhuma imagem selecionada!");
        return;
      }
      
      const coords = {
        lonMin: parseFloat(document.getElementById("lonMin").value),
        lonMax: parseFloat(document.getElementById("lonMax").value),
        latMin: parseFloat(document.getElementById("latMin").value),
        latMax: parseFloat(document.getElementById("latMax").value)
      };

      if (coords.lonMin >= coords.lonMax || coords.latMin >= coords.latMax) {
        alert("Coordenadas inv√°lidas! Verifique se:\n- Longitude M√≠nima < Longitude M√°xima\n- Latitude M√≠nima < Latitude M√°xima");
        return;
      }

      // Primeiro ajusta a visualiza√ß√£o
      const extent = new Extent({
        xmin: coords.lonMin,
        ymin: coords.latMin,
        xmax: coords.lonMax,
        ymax: coords.latMax,
        spatialReference: { wkid: 4326 }
      });

      console.log("üéØ Ajustando visualiza√ß√£o do mapa...");
      window.map.setExtent(extent.expand(1.05));

      // Aguarda um momento para o mapa se ajustar antes de carregar a imagem
      setTimeout(() => {
        window.loadImage(coords);
      }, 500);
    }

    window.cancelImageLoad = function() {
      console.log("‚ùå Cancelando carregamento da imagem");
      const coordModal = document.getElementById("coordModal");
      if (coordModal) {
        coordModal.style.display = "none";
      }
      window.currentImageURL = null;
    }

    // Fun√ß√£o para converter RGB para Hexadecimal
    function rgbToHex(r, g, b) {
      return '#' + [r, g, b].map(x => {
        const hex = x.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      }).join('');
    }

    // Fun√ß√£o para converter Hexadecimal para RGB
    function hexToRgb(hex) {
      hex = hex.replace("#", "");
      return [
        parseInt(hex.substring(0,2), 16),
        parseInt(hex.substring(2,4), 16),
        parseInt(hex.substring(4,6), 16)
      ];
    }

    // Vari√°vel global para controle de desenho
    window.isDrawing = false;

    // Fun√ß√£o para verificar se uma cor est√° pr√≥xima do alvo
    function isColorClose(r, g, b, targetR, targetG, targetB, tolerance = 30) {
      return Math.abs(r - targetR) <= tolerance &&
             Math.abs(g - targetG) <= tolerance &&
             Math.abs(b - targetB) <= tolerance;
    }

    // Fun√ß√£o para processar imagem e detectar pol√≠gonos
    function processImagePolygons(imageUrl, coords) {
      console.log("üîç Iniciando processamento da imagem...");
      
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const img = new Image();
      
      img.crossOrigin = "Anonymous";
      
      img.onload = function() {
        try {
          // Mant√©m a resolu√ß√£o original para melhor precis√£o
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);
          
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const data = imageData.data;
          
          // Ajusta as cores alvo para corresponder melhor √† imagem
          const targetColors = [
            { color: '#90EE90', rgb: [144, 238, 144], level: 0 },  // Verde claro
            { color: '#FFFF00', rgb: [255, 255, 0], level: 1 }     // Amarelo
          ];

          const colorPoints = {};
          targetColors.forEach(tc => {
            colorPoints[tc.color] = [];
          });

          // Reduz a toler√¢ncia e aumenta a densidade de amostragem
          const sampleRate = 2;  // Amostra a cada 2 pixels
          const tolerance = 50;   // Menor toler√¢ncia para cores mais precisas
          
          console.log("‚öôÔ∏è Processando pixels...");
          
          for (let y = 0; y < canvas.height; y += sampleRate) {
            for (let x = 0; x < canvas.width; x += sampleRate) {
              const idx = (y * canvas.width + x) * 4;
              const r = data[idx];
              const g = data[idx + 1];
              const b = data[idx + 2];
              const a = data[idx + 3];
              
              if (a < 128) continue; // Ignora pixels muito transparentes

              targetColors.forEach(tc => {
                const [tr, tg, tb] = tc.rgb;
                if (isColorClose(r, g, b, tr, tg, tb, tolerance)) {
                  const lon = coords.lonMin + (x / canvas.width) * (coords.lonMax - coords.lonMin);
                  const lat = coords.latMax - (y / canvas.height) * (coords.latMax - coords.latMin);
                  colorPoints[tc.color].push([lon, lat]);
                }
              });
            }
          }

          console.log("üé® Pontos encontrados por cor:", 
            Object.entries(colorPoints).map(([color, points]) => ({
              cor: color,
              pontos: points.length
            }))
          );

          // Processa cada cor separadamente
          const polygons = [];
          
          Object.entries(colorPoints).forEach(([color, points]) => {
            if (points.length < 3) return;

            console.log(`\nüîÑ Processando cor ${color} com ${points.length} pontos`);
            
            try {
              // Ajusta par√¢metros do DBSCAN para melhor agrupamento
              const eps = 0.1;     // Reduz a dist√¢ncia para grupos mais precisos
              const minPts = 5;    // Aumenta pontos m√≠nimos para clusters mais robustos
              
              console.log(`üìä Iniciando DBSCAN com eps=${eps}, minPts=${minPts}`);
              const clusters = dbscan(points, eps, minPts);
              console.log(`‚úÖ DBSCAN encontrou ${clusters.length} clusters`);
              
              // Processa apenas os maiores clusters
              const sortedClusters = clusters
                .sort((a, b) => b.length - a.length)
                .slice(0, 3);  // Pega os 3 maiores clusters
              
              sortedClusters.forEach((cluster, i) => {
                if (cluster.length < 10) return; // Ignora clusters muito pequenos
                
                try {
                  console.log(`üîÑ Processando cluster ${i + 1} com ${cluster.length} pontos`);
                  
                  // Usa ConvexHull para criar o pol√≠gono
                  const hull = turf.convex(turf.points(cluster));
                  if (hull) {
                    // Simplifica e suaviza o pol√≠gono
                    const simplified = turf.simplify(hull, {tolerance: 0.01, highQuality: true});
                    const buffered = turf.buffer(simplified, 0.05, {units: 'degrees'});
                    
                    const level = targetColors.find(tc => tc.color === color).level;
                    polygons.push({
                      level: level,
                      color: color,
                      points: buffered.geometry.coordinates[0]
                    });
                    console.log(`‚úÖ Pol√≠gono n√≠vel ${level} criado com ${cluster.length} pontos`);
                  }
                } catch (err) {
                  console.error(`‚ùå Erro ao processar cluster ${i + 1}:`, err);
                }
              });
            } catch (err) {
              console.error(`‚ùå Erro ao processar ${color}:`, err);
            }
          });

          console.log(`‚úÖ ${polygons.length} pol√≠gonos detectados!`);
          
          if (polygons.length > 0) {
            drawDetectedPolygons(polygons);
          } else {
            console.warn("‚ö†Ô∏è Nenhum pol√≠gono foi detectado!");
          }
          
        } catch (err) {
          console.error("‚ùå Erro no processamento da imagem:", err);
        }
      };
      
      img.onerror = function(err) {
        console.error("‚ùå Erro ao carregar imagem:", err);
        alert("Erro ao carregar imagem. Verifique se o formato √© suportado.");
      };
      
      img.src = imageUrl;
    }

    // Fun√ß√£o auxiliar para verificar proximidade de cores
    function isColorClose(r, g, b, targetR, targetG, targetB, tolerance = 50) {
      return Math.abs(r - targetR) <= tolerance &&
             Math.abs(g - targetG) <= tolerance &&
             Math.abs(b - targetB) <= tolerance;
    }

    // Inicializa os handlers dos bot√µes do modal
    window.initModalButtons = function() {
      console.log("üîÑ Tentando inicializar bot√µes do modal...");
      
      const btnAutoLoad = document.getElementById("btnAutoLoad");
      const btnLoadCoords = document.getElementById("btnLoadCoords");
      const btnCancelLoad = document.getElementById("btnCancelLoad");
      
      if (!btnAutoLoad || !btnLoadCoords || !btnCancelLoad) {
        console.log("‚è≥ Bot√µes do modal ainda n√£o dispon√≠veis...");
        return false;
      }

      console.log("‚úÖ Bot√µes encontrados, adicionando handlers...");
      
      // Remove handlers antigos se existirem
      btnAutoLoad.removeEventListener("click", window.autoLoadImage);
      btnLoadCoords.removeEventListener("click", window.loadImageWithCoords);
      btnCancelLoad.removeEventListener("click", window.cancelImageLoad);

      // Adiciona novos handlers
      btnAutoLoad.addEventListener("click", window.autoLoadImage);
      btnLoadCoords.addEventListener("click", window.loadImageWithCoords);
      btnCancelLoad.addEventListener("click", window.cancelImageLoad);

      console.log("‚úÖ Handlers dos bot√µes do modal configurados");
      
      return true;
    };

    // Tenta inicializar os bot√µes do modal
    if (!window.initModalButtons()) {
      console.log("üîç Configurando observer para bot√µes do modal...");
      
      const observer = new MutationObserver(function(mutations) {
        if (window.initModalButtons()) {
          console.log("‚úÖ Handlers dos bot√µes inicializados via observer!");
          observer.disconnect();
        }
      });

      observer.observe(document.body, {
        childList: true,
        subtree: true
      });
    }

    // Implementa√ß√£o simplificada do DBSCAN
    function dbscan(points, eps, minPts) {
      const clusters = [];
      const visited = new Set();
      
      points.forEach((point, i) => {
        if (visited.has(i)) return;
        visited.add(i);
        
        const neighbors = getNeighbors(point, points, eps);
        if (neighbors.length < minPts) return;
        
        const cluster = [point];
        const stack = [...neighbors];
        
        while (stack.length > 0) {
          const current = stack.pop();
          const currentIdx = points.findIndex(p => p[0] === current[0] && p[1] === current[1]);
          
          if (!visited.has(currentIdx)) {
            visited.add(currentIdx);
            const currentNeighbors = getNeighbors(current, points, eps);
            
            if (currentNeighbors.length >= minPts) {
              stack.push(...currentNeighbors.filter(n => 
                !visited.has(points.findIndex(p => p[0] === n[0] && p[1] === n[1]))
              ));
            }
          }
          
          cluster.push(current);
        }
        
        clusters.push(cluster);
      });
      
      return clusters;
    }

    function getNeighbors(point, points, eps) {
      return points.filter(p => 
        Math.sqrt(Math.pow(p[0] - point[0], 2) + Math.pow(p[1] - point[1], 2)) <= eps
      );
    }

    function drawDetectedPolygons(detectedPolygons) {
      console.log("üé® Desenhando pol√≠gonos detectados...");
      
      // Limpa pol√≠gonos existentes
      const currentHazard = document.getElementById("hazardSel").value;
      if (polygonGroups[currentHazard]) {
        polygonGroups[currentHazard].forEach(g => window.map.graphics.remove(g));
        polygonGroups[currentHazard] = [];
      }
      
      // Debug do contorno do Brasil
      console.log("üó∫Ô∏è Contorno do Brasil:", brazilBoundary);
      
      detectedPolygons.forEach((poly, index) => {
        try {
          console.log(`\nüîÑ Processando pol√≠gono ${index + 1}:`, poly.points.length, "pontos");
          
          // Verifica se os pontos est√£o em formato v√°lido
          if (!poly.points || !Array.isArray(poly.points)) {
            console.error("‚ùå Pontos inv√°lidos para o pol√≠gono", index);
            return;
          }

          // Verifica se o pol√≠gono tem pontos suficientes
          if (poly.points.length < 3) {
            console.warn(`‚ö†Ô∏è Pol√≠gono ${index + 1} tem menos de 3 pontos`);
            return;
          }

          // Debug dos pontos
          console.log("üìç Primeiro ponto:", poly.points[0]);
          console.log("üìç √öltimo ponto:", poly.points[poly.points.length - 1]);
          
          // Cria o pol√≠gono no mapa
          const polygon = new Polygon({
            rings: [poly.points],
            spatialReference: { wkid: 4326 }
          });

          // Tenta intersectar com o Brasil
          if (brazilBoundary) {
            try {
              // Cria um buffer ao redor do pol√≠gono para ser mais tolerante
              const turfPoly = {
                type: "Feature",
                geometry: {
                  type: "Polygon",
                  coordinates: [poly.points]
                }
              };

              // Adiciona um buffer de 0.1 graus (~11km)
              const buffered = turf.buffer(turfPoly, 0.1, {units: 'degrees'});
              console.log(`üîç Pol√≠gono ${index + 1} com buffer:`, buffered.geometry.coordinates[0].length, "pontos");

              // Tenta intersectar o pol√≠gono com buffer
              const intersection = turf.intersect(buffered, brazilBoundary);
              
              if (!intersection) {
                console.warn(`‚ö†Ô∏è Pol√≠gono ${index + 1} n√£o intersecta com o Brasil mesmo com buffer`);
                // Usa o pol√≠gono original mesmo sem intersec√ß√£o
              } else {
                // Usa a intersec√ß√£o se dispon√≠vel
                polygon.rings = intersection.geometry.coordinates;
                console.log(`‚úÖ Pol√≠gono ${index + 1} intersectado com sucesso`);
              }
            } catch (err) {
              console.error(`‚ùå Erro ao processar intersec√ß√£o do pol√≠gono ${index + 1}:`, err);
              // Continua com o pol√≠gono original em caso de erro
            }
          }
          
          // Cria o s√≠mbolo baseado no n√≠vel
          const color = catColor[poly.level] || "#999";
          const symbol = new SimpleFillSymbol(
            SimpleFillSymbol.STYLE_SOLID,
            new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color(color), 2),
            new Color([...hexToRgb(color), 0.25])
          );

          // Cria o gr√°fico
          const graphic = new Graphic(polygon, symbol);
          
          // Define atributos
          const hazard = document.getElementById("hazardSel").value;
          graphic.setAttributes({
            level: poly.level,
            hazard: hazard,
            prob: 15
          });
          
          // Adiciona ao grupo apropriado
          if (!polygonGroups[hazard]) {
            polygonGroups[hazard] = [];
          }
          polygonGroups[hazard].push(graphic);
          
          // Adiciona ao mapa
          window.map.graphics.add(graphic);
          console.log(`‚úÖ Pol√≠gono ${index + 1} adicionado ao mapa`);

        } catch (err) {
          console.error(`‚ùå Erro ao processar pol√≠gono ${index}:`, err);
        }
      });
      
      console.log(`‚úÖ Processamento finalizado: ${polygonGroups[currentHazard]?.length || 0} pol√≠gonos no mapa`);
    }

    // Modifica a fun√ß√£o loadImage para incluir o processamento de pol√≠gonos
    window.loadImage = function(coords) {
      console.log("üéØ Iniciando processamento da imagem...");
      console.log("üìç Coordenadas:", coords);
      console.log("üñºÔ∏è URL da imagem:", window.currentImageURL ? "Dispon√≠vel" : "N√£o dispon√≠vel");

      if (!window.map) {
        console.error("‚ùå Mapa ainda n√£o foi inicializado!");
        return;
      }

      try {
        // Remove overlay anterior se existir
        if (window.imageOverlay) {
          console.log("üóëÔ∏è Removendo overlay anterior...");
          window.map.removeLayer(window.imageOverlay);
          window.imageOverlay = null;
        }

        // Processa a imagem para detectar pol√≠gonos
        processImagePolygons(window.currentImageURL, coords);

        // Fecha o modal de coordenadas
        const coordModal = document.getElementById("coordModal");
        if (coordModal) coordModal.style.display = "none";

        console.log("‚úÖ Processamento de pol√≠gonos iniciado!");
      } catch (error) {
        console.error("‚ùå Erro ao processar imagem:", error);
        alert("Erro ao processar imagem: " + error.message);
      }
    }

    // Remove os event listeners de overlay que n√£o s√£o mais necess√°rios
    const toggleOverlay = document.getElementById("toggleOverlay");
    if (toggleOverlay) {
      toggleOverlay.parentElement.style.display = "none";
    }

    const opacityControl = document.getElementById("opacityControl");
    if (opacityControl) {
      opacityControl.style.display = "none";
    }

    // Configura√ß√£o global das camadas do CPTEC
    window.CPTEC_LAYERS = {
      PPI: {
        SANTIAGO: "radar:santiago_ppi_latest",
        MORRO_DA_IGREJA: "radar:mdi_ppi_latest",
        CANGUCU: "radar:cng_ppi_latest",
        CHAPECO: "radar:chp_ppi_latest"
      },
      DOPPLER: {
        SANTIAGO: "radar:santiago_doppler_latest",
        MORRO_DA_IGREJA: "radar:mdi_doppler_latest",
        CANGUCU: "radar:cng_doppler_latest",
        CHAPECO: "radar:chp_doppler_latest"
      }
    };

    // Fun√ß√£o para adicionar camada do radar CPTEC
    window.addCPTECRadar = function(radarId, type) {
      const layerId = window.CPTEC_LAYERS[type][radarId];
      console.log(`üéØ Adicionando camada ${layerId}...`);
      
      // Remove camada anterior se existir
      if (window.cptecLayers?.[layerId]) {
        window.map.removeLayer(window.cptecLayers[layerId]);
      }

      try {
        // Cria nova camada usando WMSLayer
        const layer = new WMSLayer("https://radar.cptec.inpe.br/geoserver/wms", {
          id: layerId,
          visibleLayers: [layerId],
          version: "1.1.1",
          format: "image/png",
          transparent: true,
          opacity: 0.8,
          spatialReference: new SpatialReference({ wkid: 4326 })
        });

        // Define a extens√£o inicial
        layer.initialExtent = new Extent({
          xmin: -60,
          ymin: -35,
          xmax: -45,
          ymax: -20,
          spatialReference: new SpatialReference({ wkid: 4326 })
        });

        layer.fullExtent = layer.initialExtent;

        // Armazena refer√™ncia da camada
        if (!window.cptecLayers) window.cptecLayers = {};
        window.cptecLayers[layerId] = layer;

        // Adiciona ao mapa
        window.map.addLayer(layer);
        console.log(`‚úÖ Camada ${layerId} adicionada`);
      } catch (err) {
        console.error(`‚ùå Erro ao adicionar camada ${layerId}:`, err);
      }
    };

    // Fun√ß√£o global para remover camada do radar CPTEC
    window.removeCPTECRadar = function(radarId, type) {
      const layerId = window.CPTEC_LAYERS[type][radarId];
      if (window.cptecLayers?.[layerId]) {
        window.map.removeLayer(window.cptecLayers[layerId]);
        delete window.cptecLayers[layerId];
        console.log(`‚úÖ Camada ${layerId} removida`);
      }
    };

    // Fun√ß√£o global para adicionar controles do CPTEC
    window.addCPTECControls = function() {
      const overlayControls = document.getElementById("overlayControls");
      if (!document.getElementById("cptecControls")) {
        const div = document.createElement("div");
        div.id = "cptecControls";
        div.className = "radar-controls";
        
        div.innerHTML = `
          <h4>Radares CPTEC</h4>
          <div class="radar-group">
            <h5>Santiago</h5>
            <label><input type="checkbox" onchange="this.checked ? window.addCPTECRadar('SANTIAGO', 'PPI') : window.removeCPTECRadar('SANTIAGO', 'PPI')"> PPI</label>
            <label><input type="checkbox" onchange="this.checked ? window.addCPTECRadar('SANTIAGO', 'DOPPLER') : window.removeCPTECRadar('SANTIAGO', 'DOPPLER')"> Doppler</label>
          </div>
          <div class="radar-group">
            <h5>Morro da Igreja</h5>
            <label><input type="checkbox" onchange="this.checked ? window.addCPTECRadar('MORRO_DA_IGREJA', 'PPI') : window.removeCPTECRadar('MORRO_DA_IGREJA', 'PPI')"> PPI</label>
            <label><input type="checkbox" onchange="this.checked ? window.addCPTECRadar('MORRO_DA_IGREJA', 'DOPPLER') : window.removeCPTECRadar('MORRO_DA_IGREJA', 'DOPPLER')"> Doppler</label>
          </div>
          <div class="radar-group">
            <h5>Cangu√ßu</h5>
            <label><input type="checkbox" onchange="this.checked ? window.addCPTECRadar('CANGUCU', 'PPI') : window.removeCPTECRadar('CANGUCU', 'PPI')"> PPI</label>
            <label><input type="checkbox" onchange="this.checked ? window.addCPTECRadar('CANGUCU', 'DOPPLER') : window.removeCPTECRadar('CANGUCU', 'DOPPLER')"> Doppler</label>
          </div>
          <div class="radar-group">
            <h5>Chapec√≥</h5>
            <label><input type="checkbox" onchange="this.checked ? window.addCPTECRadar('CHAPECO', 'PPI') : window.removeCPTECRadar('CHAPECO', 'PPI')"> PPI</label>
            <label><input type="checkbox" onchange="this.checked ? window.addCPTECRadar('CHAPECO', 'DOPPLER') : window.removeCPTECRadar('CHAPECO', 'DOPPLER')"> Doppler</label>
          </div>
        `;
        
        overlayControls.appendChild(div);
      }
    }

    // Fun√ß√£o para inicializa√ß√£o segura dos componentes
    function safeInitialize() {
      console.log("üîÑ Iniciando inicializa√ß√£o segura dos componentes...");
      
      // Verifica se os elementos necess√°rios existem
      const requiredElements = [
        "geoImageInput",
        "coordModal",
        "toggleOverlay",
        "opacityControl",
        "opacitySlider",
        "opacityValue",
        "toggleRainviewer",
        "toggleMunicipios"
      ];

      const missingElements = requiredElements.filter(id => !document.getElementById(id));
      
      if (missingElements.length > 0) {
        console.warn("‚ö†Ô∏è Elementos pendentes:", missingElements);
        // Tenta novamente em 100ms
        setTimeout(safeInitialize, 100);
        return;
      }

      try {
        console.log("‚úÖ Todos os elementos encontrados, inicializando...");
        
        // Inicializa os listeners
        initCheckboxListeners();
        initModalButtons();
        
        // Inicializa handlers de arquivo
        const input = document.getElementById("geoImageInput");
        if (input && !input.hasEventListener) {
          input.addEventListener("change", handleFileSelect);
          input.hasEventListener = true;
        }

        console.log("‚úÖ Inicializa√ß√£o conclu√≠da com sucesso");
      } catch (err) {
        console.error("‚ùå Erro durante inicializa√ß√£o:", err);
      }
    }

    // Inicia a inicializa√ß√£o segura quando o DOM estiver pronto
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", safeInitialize);
    } else {
      safeInitialize();
    }

    // Armazena a classe globalmente
    window.CPTECRadarLayer = CPTECRadarLayer;

  }); // end require
  </script>
</body>
</html>